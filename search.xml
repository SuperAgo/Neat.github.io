<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>离别</title>
      <link href="/2020/02/25/leaving/"/>
      <url>/2020/02/25/leaving/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>少年总向望着远方<br>梦想的远方总是美好<br>一次次送别<br>脚步越来越远<br>他乡广阔却也寂寥<br>累了回头歇歇脚<br>人潮人海中<br>无声牵挂总在背后</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=484732237&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小诗集 </tag>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Controller与@RestController的区别</title>
      <link href="/2019/06/30/Difference-between-Controller-and-RestController/"/>
      <url>/2019/06/30/Difference-between-Controller-and-RestController/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.使用@RestController注解相当于同时在Controller上使用了@Controller+@ResponsBody注解（或者Controller上使用@Controller注解+方法块上使用@ResponseBody注解）；<br>2.只在Controller上使用@RestController注解只能返回return中的内容无法返回jsp/html页面(配置的视图解析器 InternalResourceViewResolver不起作用)<br>3.若想使Controller返回视图则需使用@Controller注解；同时需要返回数据则需在对应方法上加注@ResponseBody</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2019/06/26/Linux-common-commands/"/>
      <url>/2019/06/26/Linux-common-commands/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h5><pre><code>命令格式：cd &lt;路径&gt;  </code></pre><p>意义：cd是change directory 的缩写；cd命令后面跟一个路径，用于切换当前用户所在的路径，其中路径可以是绝对路径也可以是相对路径。<br>示例：<br><code>cd /system/bin</code> 表示切换到/system/bin路径下。<br><code>cd logs</code> 表示切换到logs路径下。<br><code>cd /</code> 表示切换到根目录。<br><code>cd ../</code> 表示切换到上一层路径。</p><h5 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h5><pre><code>命令格式：ls &lt;参数&gt; &lt;路径&gt;</code></pre><p>意义：ls是list的缩写；ls命令后面可以跟一个路径或参数，也可以不跟，表示列出路径或当前目录下的所有文件信息。最常用的的参数是“-l”，也就是“ls -l”命令。<br>示例：<br><code>ls /</code>显示根目录下的所有文件及文件夹。<br><code>ls -l /data</code>显示/data路径下的所有文件及文件夹的详细信息。<br><code>ls -l</code>显示当前路径下的所有文件及文件夹的详细信息<br><code>ls *l wc</code>显示当前目录下面的文件数量。</p><h5 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h5><pre><code>命令格式： rm &lt;文件&gt; 或 rm -r &lt;文件夹&gt;</code></pre><p>意义：rm是remove 的缩写。用于删除文件或文件夹，常用参数-r -f，-r表示删除目录，也可以用于删除文件，-f表示强制删除，不需要确认。同样的，删除文件前需保证当前用户对当前路径有修改的权限。<br>示例：<br><code>rm -rf path</code> 删除path。<br><code>rm test.txt</code> 删除test.txt。</p><h5 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h5><pre><code>命令格式： mkdir 文件夹  </code></pre><p>意义：mkdir是make directory 的缩写。用于创建文件夹。创建文件夹前需保证当前用户对当前路径有修改的权限。<br>示例：<br><code>mkdir /data/path</code> 在/data路径下创建path文件夹。<br><code>mkdir -p a/b/c</code> 参数 -p用于创建多级文件夹，这句命令表示在当前路径下创建文件夹a， 而a文件夹包含子文件夹b，b文件夹下又包含子文件夹c。</p><h5 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h5><pre><code>命令格式： cp &lt;文件&gt;&lt;目标文件&gt;或者cp -r&lt;文件夹&gt;&lt;目标文件夹&gt;</code></pre><p>意义：cp是copy 的缩写。用于复制文件或文件夹。<br>示例：<br><code>cp /data/logs /data/local/tmp/logs</code>复制/data路径下的logs到/data/local/tmp路径下。<br><code>cp 1.sh /sdcard/</code> 复制当前路径下的1.sh到/sdcard下。</p><h5 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h5><pre><code>ps [options] [--help]</code></pre><p>用于显示当前进程 (process) 的状态。<br>参数：</p><p>ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义<br>-A 列出所有的行程<br>-w 显示加宽可以显示较多的资讯<br>-au 显示较详细的资讯<br>-aux 显示所有包含其他使用者的行程<br>au(x) 输出格式 :<br>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND<br>USER: 行程拥有者<br>PID: pid<br>%CPU: 占用的 CPU 使用率<br>%MEM: 占用的记忆体使用率<br>VSZ: 占用的虚拟记忆体大小<br>RSS: 占用的记忆体大小<br>TTY: 终端的次要装置号码 (minor device number of tty)<br>STAT: 该行程的状态:<br>D: 无法中断的休眠状态 (通常 IO 的进程)<br>R: 正在执行中<br>S: 静止状态<br>T: 暂停执行<br>Z: 不存在但暂时无法消除<br>W: 没有足够的记忆体分页可分配<br>&lt;: 高优先序的行程<br>N: 低优先序的行程<br>L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)<br>START: 行程开始时间<br>TIME: 执行的时间<br>COMMAND:所执行的指令<br>示例：<br><code>ps -A</code> 显示进程信息<br>显示指定用户信息<br><code>ps -u root</code>显示root进程用户信息<br>显示所有进程信息，连同命令行<br><code>ps -ef</code>显示所有命令，连带命令行<br><code>ps -ef |grep java</code> 正在运行的java进程</p><h5 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h5><pre><code>命令格式：kill PID码  </code></pre><p>意义：结束当前进程<br>示例：<br>先通过输入命令<code>ps au</code>查看进程，找到需要终止进程的PID再通过kill PID即可，如我这里想要终止的进程是vim test.py，查到的PID是3163，我们可以输入kill 3163结束这个程序，如果结束不了，可以通过kill -9 PID码强制结束，即kii -9 3163</p><h5 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h5><pre><code>命令格式：find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \;</code></pre><p>意义：在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。 </p><p>参数说明 :</p><p>find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p><p>expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</p><p>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</p><p>-amin n : 在过去 n 分钟内被读取过</p><p>-anewer file : 比文件 file 更晚被读取过的文件</p><p>-atime n : 在过去n天内被读取过的文件</p><p>-cmin n : 在过去 n 分钟内被修改过</p><p>-cnewer file :比文件 file 更新的文件</p><p>-ctime n : 在过去n天内被修改过的文件</p><p>-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</p><p>-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</p><p>-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写</p><p>-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。</p><p>d: 目录</p><p>c: 字型装置文件</p><p>b: 区块装置文件</p><p>p: 具名贮列</p><p>f: 一般文件</p><p>l: 符号连结</p><p>s: socket</p><p>-pid n : process id 是 n 的文件</p><p>你可以使用 ( ) 将运算式分隔，并使用下列运算。</p><p>exp1 -and exp2</p><p>! expr</p><p>-not expr</p><p>exp1 -or exp2</p><p>exp1, exp2<br>示例：<br><code>find . -name &quot;*.c&quot;</code>将目前目录及其子目录下所有延伸档名是 c 的文件列出来。<br><code># find . -type f</code>将目前目录其其下子目录中所有一般文件列出<br><code>find / -size +500M -print0|xargs -0 du -m|sort -nr</code>find指令为找出500M以上的文件，print0和xargs -0配合使用，用来解决文件名中有空格或特殊字符问题。du -m是查看这些文件的大小，并以m为单位显示。最后sort -nr是按照数字反向排序（大的文件在前）<br><code>find / -name *xxx*.c</code> 模糊查找xxx.c的文件</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat部署（多）项目</title>
      <link href="/2019/06/25/Tomcat-build-projects/"/>
      <url>/2019/06/25/Tomcat-build-projects/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="1-单个项目"><a href="#1-单个项目" class="headerlink" title="1.单个项目"></a>1.单个项目</h5><pre><code>  1.1 jar省略  1.2 war  1.3 静态项目详略</code></pre><h5 id="2-多个项目"><a href="#2-多个项目" class="headerlink" title="2.多个项目"></a>2.多个项目</h5><pre><code>2.1 单个Tomcat略。参考（https://www.cnblogs.com/casefour/p/11843582.html）2.2 多个Tomcat以windows为例，安装配置多个tomcat后，不同的tomcat配置不同的端口，打开cmd分别进入各个tomcat的bin文件夹输入命令```service.bat install/remove [service_name]/[user username]```进行服务的安装卸载。不同端口服务应起不同的名字，不然会报错。然后就可以在windows的服务里进行设置服务的启停以及开机启动。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Tomcat </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nginx实现负载均衡</title>
      <link href="/2019/05/15/nginx-load-balancing/"/>
      <url>/2019/05/15/nginx-load-balancing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、Nginx负载均衡的集中方式介绍"><a href="#一、Nginx负载均衡的集中方式介绍" class="headerlink" title="一、Nginx负载均衡的集中方式介绍"></a><strong>一、Nginx负载均衡的集中方式介绍</strong></h3><p><strong>1.1 轮询</strong><br>轮询方式是Nginx负载默认的方式，顾名思义，所有请求都按照时间顺序分配到不同的服务上，如果服务Down掉，可以自动剔除，如下配置后轮训1001服务和1002服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream  localhost-server &#123;</span><br><span class="line">       server    localhost:1001;</span><br><span class="line">       server    localhost:1002;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1.2 权重</strong><br>指定每个服务的权重比例，weight和访问比率成正比，通常用于后端服务机器性能不统一，将性能好的分配权重高来发挥服务器最大性能，如下配置后1002服务的访问比率会是1001服务的二倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream  localhost-server &#123;</span><br><span class="line">       server    localhost:1001 weight&#x3D;1;</span><br><span class="line">       server    localhost:1002 weight&#x3D;2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1.3 iphash</strong><br>每个请求都根据访问ip的hash结果分配，经过这样的处理，每个访客固定访问一个后端服务，如下配置（ip_hash可以和weight配合使用）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream  localhost-server &#123;</span><br><span class="line">       ip_hash; </span><br><span class="line">       server    localhost:1001 weight&#x3D;1;</span><br><span class="line">       server    localhost:1002 weight&#x3D;2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1.4 最少连接</strong><br>将请求分配到连接数最少的服务上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream  localhost-server &#123;</span><br><span class="line">       least_conn;</span><br><span class="line">       server    localhost:1001 weight&#x3D;1;</span><br><span class="line">       server    localhost:1002 weight&#x3D;2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1.5 fair</strong><br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream  localhost-server &#123;</span><br><span class="line">       server    localhost:1001 weight&#x3D;1;</span><br><span class="line">       server    localhost:1002 weight&#x3D;2;</span><br><span class="line">       fair;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、Nginx配置"><a href="#二、Nginx配置" class="headerlink" title="二、Nginx配置"></a><strong>二、Nginx配置</strong></h3><p>以轮训为例，nginx.conf完整代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">   upstream  localhost-server &#123;</span><br><span class="line">       server    localhost:1001;</span><br><span class="line">       server    localhost:1002;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   server &#123;</span><br><span class="line">       listen       80;</span><br><span class="line">       server_name  localhost;</span><br><span class="line"></span><br><span class="line">       location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost-server;</span><br><span class="line">        proxy_redirect default;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要修改负载均衡算法修改对应upstream模块即可。</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装Nginx</title>
      <link href="/2019/05/13/Docker-pull-Nginx/"/>
      <url>/2019/05/13/Docker-pull-Nginx/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="查看可用的-Nginx-版本"><a href="#查看可用的-Nginx-版本" class="headerlink" title="查看可用的 Nginx 版本"></a><strong>查看可用的 Nginx 版本</strong></h4><p>可以用<code>docker search nginx</code> 命令来查看可用版本</p><h4 id="取-Nginx-镜像"><a href="#取-Nginx-镜像" class="headerlink" title="取 Nginx 镜像"></a><strong>取 Nginx 镜像</strong></h4><p>这里我们拉取官方的最新版本的镜像：<code>docker pull nginx:latest</code>  </p><h4 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a><strong>查看本地镜像</strong></h4><p>使用以下命令来查看是否已安装了 nginx：<code>docker images</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              c7460dfcab50        2 months ago        126MB</span><br><span class="line">redis               latest              f7302e4ab3a8        7 months ago        98.2MB</span><br></pre></td></tr></table></figure><p>可以看到我们已经安装了最新版本（latest）的 nginx 镜像。</p><h4 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a><strong>运行容器</strong></h4><p>安装完成后，我们可以使用以下命令来运行 nginx 容器：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx-test -p 8080:80 -d nginx</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>–name nginx-test：容器名称。<br>-p 8080:80： 端口进行映射，将本地 8080 端口映射到容器内部的 80 端口。<br>-d nginx： 设置容器在在后台一直运行。</p><h4 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功"></a><strong>安装成功</strong></h4><p>最后我们可以通过浏览器可以直接访问 8080 端口的 nginx 服务。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker使用</title>
      <link href="/2019/05/13/Docker/"/>
      <url>/2019/05/13/Docker/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Docker的简介"><a href="#Docker的简介" class="headerlink" title="Docker的简介"></a>Docker的简介</h3><p>Docker 是一个开源的应用容器引擎，基于Go语言并遵从Apache2.0协议开源。让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。</p><h3 id="Docker的组成："><a href="#Docker的组成：" class="headerlink" title="Docker的组成："></a>Docker的组成：</h3><p>1 Docker Client 客户端<br>2 Docker Daemon 守护进程<br>3 Docker Image 镜像<br>4 Docker Container 容器<br>从2017年3月开始Docker在原来的基础上分为两个分支版本: Docker CE 和 Docker EE。Docker CE 即社区免费版，Docker EE 即企业版，强调安全，但需付费使用。</p><h3 id="Docker-CE的安装"><a href="#Docker-CE的安装" class="headerlink" title="Docker CE的安装"></a>Docker CE的安装</h3><p>1 较旧版本的Docker被称为docker或docker-engine,如果已安装这些，请卸载它们。未安装略过此步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum remove -y docker \</span><br><span class="line">              docker-client \</span><br><span class="line">              docker-client-latest \</span><br><span class="line">              docker-common \</span><br><span class="line">              docker-latest \</span><br><span class="line">              docker-latest-logrotate \</span><br><span class="line">              docker-logrotate \</span><br><span class="line">              docker-engine</span><br></pre></td></tr></table></figure><p>2 安装所需要的软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>3 设置Docker的存储库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><p>4 安装最新版Docker-ce</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><p><strong>如遇错误提示：</strong><br>错误：软件包：3:docker-ce-18.09.6-3.el7.x86_64 (docker-ce-stable)<br>需要：container-selinux &gt;= 2.9</p><p>执行以下命令,下载container-selinux-2.95的rpm包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;mirror.centos.org&#x2F;centos&#x2F;7&#x2F;extras&#x2F;x86_64&#x2F;Packages&#x2F;container-selinux-2.95-2.el7_6.noarch.rpm</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh container-selinux-2.95-2.el7_6.noarch.rpm</span><br></pre></td></tr></table></figure><p>再次执行安装命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><p>5 启动docke</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure><p>查看docker的版本</p><figure class="highlight docker"><figcaption><span>version ```显示</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">Client:</span><br><span class="line"> Version:           <span class="number">18.09</span>.<span class="number">6</span></span><br><span class="line"> API version:       <span class="number">1.39</span></span><br><span class="line"> Go version:        go1.<span class="number">10.8</span></span><br><span class="line"> Git commit:        <span class="number">481</span>bc77156</span><br><span class="line"> Built:             Sat May  <span class="number">4</span> <span class="number">02</span>:<span class="number">34</span>:<span class="number">58</span> <span class="number">2019</span></span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Experimental:      false</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          <span class="number">18.09</span>.<span class="number">6</span></span><br><span class="line">  API version:      <span class="number">1.39</span> (minimum version <span class="number">1.12</span>)</span><br><span class="line">  Go version:       go1.<span class="number">10.8</span></span><br><span class="line">  Git commit:       <span class="number">481</span>bc77</span><br><span class="line">  Built:            Sat May  <span class="number">4</span> <span class="number">02</span>:<span class="number">02</span>:<span class="number">43</span> <span class="number">2019</span></span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br></pre></td></tr></table></figure><p>即<strong>安装成功</strong><br><strong>查看更详细的的信息</strong><code>docker info</code><br><strong>Docker常用命令</strong><br>可以直接在终端输入<code>docker --help</code>列出所有docker的用法以及所有命令</p><p><strong>查看本地存在的docker镜像</strong><code>docker images</code></p><pre><code>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEnginx               latest              c7460dfcab50        2 months ago        126MBredis               latest              f7302e4ab3a8        7 months ago        98.2MB</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2019/03/28/MyBatis/"/>
      <url>/2019/03/28/MyBatis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="和-的区别。"><a href="#和-的区别。" class="headerlink" title="#{}和${}的区别。"></a>#{}和${}的区别。</h5><p>#{}是预编译处理，${}是字符串替换。<br>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；<br>Mybatis在处理{}替换成变量的值。<br>使用#{}可以有效的防止SQL注入，提高系统安全性。</p><h5 id="如何获取自动生成的-主-键值。"><a href="#如何获取自动生成的-主-键值。" class="headerlink" title="如何获取自动生成的(主)键值。"></a>如何获取自动生成的(主)键值。</h5><p>insert 方法总是返回一个int值 - 这个值代表的是插入的行数。<br>而自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。<br>示例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id&#x3D;&quot;insert&quot; parameterType&#x3D;&quot;Spares&quot; </span><br><span class="line">        useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;id&quot;&gt;</span><br><span class="line">INSERT INTO spares </span><br><span class="line">(spares_id, spares_name, spares_type_id, spares_spec)</span><br><span class="line">VALUES </span><br><span class="line">(#&#123;id&#125;, #&#123;name&#125;, #&#123;typeId&#125;, #&#123;spec&#125;)</span><br><span class="line">&lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>后台运行hexo</title>
      <link href="/2019/03/02/Background-process-hexo/"/>
      <url>/2019/03/02/Background-process-hexo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>hexo的 hexo s命令适合本地预览，那么该如何让hexo在后台一直运行呢?<br>在使用hexo s &amp;发现在断开ssh后hexo的运行状态也会随即终止，后来发现一个方法，可以是hexo后台运行。</p><p>那就是 用pm2 来接管hexo的进程</p><p>开始操作：<br>首先安装pm2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm  install -g pm2</span><br></pre></td></tr></table></figure><p>写一个执行脚本<br>在博客根目录下面创建一个hexo_run.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;run</span><br><span class="line">const &#123; exec &#125; &#x3D; require(&#39;child_process&#39;)</span><br><span class="line">exec(&#39;hexo server&#39;,(error, stdout, stderr) &#x3D;&gt; &#123;</span><br><span class="line">        if(error)&#123;</span><br><span class="line">                console.log(&#39;exec error: $&#123;error&#125;&#39;)</span><br><span class="line">                return</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&#39;stdout: $&#123;stdout&#125;&#39;);</span><br><span class="line">        console.log(&#39;stderr: $&#123;stderr&#125;&#39;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后运行该脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;root&#x2F;xxxxxx&#x2F;blog</span><br><span class="line">pm2 start hexo_run.js</span><br></pre></td></tr></table></figure><p>绑定个人域名后即可在任何设备打开添加博文啦</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pm2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo fs.SyncWriteStream is deprecated</title>
      <link href="/2019/03/01/hexo-DEP0061/"/>
      <url>/2019/03/01/hexo-DEP0061/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用hexo-admin管理后台，在使用自动deploy时，总会报<br><code>fs.SyncWriteStream is deprecated</code><br>的错误,查找一番是现在使用的node版本不支持SyncWriteStream升级node等方法使用后均不生效。<br>后来通过–debug来查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZm5e9wgsfc1fksnwtfo33Z Neat]# hexo clean --debug</span><br><span class="line">14:08:12.283 DEBUG Writing database to &#x2F;data&#x2F;nginx&#x2F;html&#x2F;myBlog&#x2F;Neat&#x2F;db.json</span><br><span class="line">14:08:12.299 DEBUG Hexo version: 4.2.0</span><br><span class="line">14:08:12.299 DEBUG Working directory: &#x2F;data&#x2F;nginx&#x2F;html&#x2F;myBlog&#x2F;Neat&#x2F;</span><br><span class="line">14:08:12.392 DEBUG Config loaded: &#x2F;data&#x2F;nginx&#x2F;html&#x2F;myBlog&#x2F;Neat&#x2F;_config.yml</span><br><span class="line">14:08:12.489 DEBUG Plugin loaded: hexo-admin</span><br><span class="line">(node:30641) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.</span><br></pre></td></tr></table></figure><p>发现问题出在hexo-admin下的hexo-fs<br>便找到 ./node_modules/hexo-admin/<br>./node_modules/hexo-admin/node_modules/hexo-fs/lib/fs.js:718<br>将exports.SyncWriteStream = fs.SyncWriteStream;注释即可</p><p><img src="/" class="lazyload" data-src="/images/pasted-0.png"  alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> error </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
