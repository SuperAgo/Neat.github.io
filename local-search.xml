<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>那些年我们一起听过的杰伦</title>
    <link href="/2020/04/09/Jay/"/>
    <url>/2020/04/09/Jay/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>down了杰伦的歌下来，上传到网易云盘播放了<br>额，个人听听不知道会不会被告盗版。。。<br>用aplayer.js的meting</p><h2 id="1-下载插件"><a href="#1-下载插件" class="headerlink" title="1.下载插件"></a>1.下载插件</h2><p>若主题内置可直接跳至下一步</p><div class="hljs"><pre><code class="hljs plain">npm install hexo-tag-aplayer</code></pre></div><h2 id="2-config-yml添加配置"><a href="#2-config-yml添加配置" class="headerlink" title="2._config.yml添加配置"></a>2._config.yml添加配置</h2><div class="hljs"><pre><code class="hljs plain">aplayer:  meting: true</code></pre></div><h2 id="3-md语法"><a href="#3-md语法" class="headerlink" title="3.md语法"></a>3.md语法</h2><p>音乐平台: netease, tencent, kugou, xiami, baidu</p><div class="hljs"><pre><code class="hljs plain">&#123;% meting &quot;id&quot; &quot;netease&quot; &quot;playlist&quot; %&#125;</code></pre></div><p><strong>但是云盘歌单老是报错。。。可能网易云盘用了不可描述的操作（因为好多云盘的歌<del>没版权的歌</del>还能看到评论），</strong></p><p>没办法，只能用网易云的网易云的iframe,但是吧emm…样式不太支持手机端，而且手机浏览器不能播放不能滑动。 </p><div class="hljs"><pre><code class="hljs plain">&lt;div&gt;&lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;350 height&#x3D;300 src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;0&amp;id&#x3D;XXXXXXX&amp;auto&#x3D;1&amp;height&#x3D;430&quot;&gt;&lt;&#x2F;iframe&gt;&lt;&#x2F;div&gt;</code></pre></div><div>    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=350 height=300 src="//music.163.com/outchain/player?type=0&id=4945505356&auto=1&height=430">    </iframe></div><h2 id="4-meting的demo效果"><a href="#4-meting的demo效果" class="headerlink" title="4.meting的demo效果"></a>4.meting的demo效果</h2><p>放个meting的demo,QQ音乐的歌单，不过好多收费的还是没法放，聊胜于无哦</p><blockquote><p>说明meting是能用的（微信内置浏览器竟然支持，意外之喜~实测meting也不支持很多手机浏览器，不过Chrome还是支持的，不过用的人很少就是了）。</p></blockquote>    <div id="aplayer-ucqOUHEB" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="3806287274" data-server="tencent" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div>  <p>嘻嘻，又成功水了一贴（<em>^_^</em>）!</p><blockquote><p>青春有很多种，其中一种叫做周杰伦~</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>音乐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Jay Chou</tag>
      
      <tag>meting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离别</title>
    <link href="/2020/02/25/leaving/"/>
    <url>/2020/02/25/leaving/</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看加密后的内容."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="还没写完，需要密码才能看" /><label>还没写完，需要密码才能看</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="e7d050024bac98111b8872df89eb829d8fafd2887e90a52451471254be8d08b5">e02d12fb45a752628f72eca06f2445db6d333cd033e43d32f92279e33a9e959d33ad09c5c4b342405a66ef31e16efa17017b7b341936740be2859e455dcf23977358440b106330025c0cb9c3de4cce1df0bcfa6142a137c6df37e38943c055c91dc613a307af74b773f6e4caffd75eef1fe9737d5ecdc7c6df26ebc43fab6c0261dddb088fc9ee4203b2ad73e1d6ca179ca76b3a39250654b34f7b97800a392e23350ec3b833445996aec49c42849974e08897090202c0986fac01358897088bb84f4b12fb9f06e580b40504afb99c43d78acfb255b4d2d4d9f4f872aa7be4f8a3d08f204381f44ed9bf03617ef62f680c6c3b11e50319e460e3827895ddd02dffb6f6d09e5427992d352be402fe6d8e3d5aa3384ff980baeb868d26be86b483692fabe2f8fb889323280030ecac325ff267c2516709ec490fdc466ef8870c6f72252c7f2cd3a84ed9bc62cd850f2ac61df36bda37489f9f890bbc54fc3c6b3f8b901c73dd2582edcc4bb56e3907e681ce418822101a2e5e0322aae4db0e8430764fa2cf771aab210416e045c3a944cbbb4d5f99d6092487ca991b14fef219e13b89eb98254b2b4b1b1b20df271f3ecfa500f3a994015c6869a12343cbb152887ccc9301ab65c844f4b5cb119e4be42b9212e9fbc76d234ea9050ffa1509f7019a47238b47befa680514aaac6abf569210e6f538605b0bb4fe1aaa93c8ade50b38d6d411127186a12088962b1a2da65a9e529cc4694489950b77780bcf57a734fed25cee6711b575140a15f5a8fd91fb53a14fa6cb5974877a7b3a654aebb2e62c75a969940e08308d0b611aa35f272f33fe5ae7e6babb3f353819208913e8b7117199a92d343237e2b75a6184d1219c</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lock</tag>
      
      <tag>音乐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker中nginx开启https</title>
    <link href="/2019/09/18/Nginx_in_Docker_opens_https/"/>
    <url>/2019/09/18/Nginx_in_Docker_opens_https/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>打开网页老是显示不安全，强迫症的我最终决定开启https.<br>由于使用的是阿里云，所以直接在阿里云上申请了ssl，比较简单这里就不多赘述。  </p><h5 id="1-申请ssl备案通过后"><a href="#1-申请ssl备案通过后" class="headerlink" title="1.申请ssl备案通过后"></a>1.申请ssl备案通过后</h5><p><img src="/images/pasted-1.png" srcset="/img/loading.gif" alt="upload successful"><br>点击下载，选择nginx版本</p><p><img src="/images/pasted-2.png" srcset="/img/loading.gif" alt="upload successful"></p><h5 id="2-nginx配置"><a href="#2-nginx配置" class="headerlink" title="2.nginx配置"></a>2.nginx配置</h5><p>首先将下载的pem文件和key文件上传至服务器nginx文件夹下（方便自己记忆的文件夹/映射文件夹）<br>然后打开nginx的配置文件<br>新增如下配置，开启http请求自动重定向至https</p><div class="hljs"><pre><code class="hljs plain">server &#123;        listen       80;        server_name  XXXXX;        return 301 https:&#x2F;&#x2F;$server_name$request_uri;   #将所有http请求通过rewrite重定向到https。    &#125;</code></pre></div><p>然后添加</p><div class="hljs"><pre><code class="hljs plain">server &#123;       listen443 ssl;       server_name  XXXXX;   #ssl on      ssl_certificate &#x2F;etc&#x2F;ssl&#x2F;XXXXXX.pem;   #将domain name.pem替换成您证书的文件名。   ssl_certificate_key &#x2F;etc&#x2F;ssl&#x2F;XXXXXX.key;   #将domain name.key替换成您证书的密钥文件名。   ssl_session_timeout 5m;   ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  #使用此加密套件。   ssl_protocols TLSv1 TLSv1.1 TLSv1.2;   #使用该协议进行配置。   ssl_prefer_server_ciphers on;</code></pre></div><p>根据不同网站对不同浏览器的支持，<code>ssl_ciphers</code>与<code>ssl_protocols</code>可以斟酌配置  </p><hr><p><u><a href="#1">SSL／TLS 系列中有<strong>五种</strong>协议</a></u><sup>1</sup>：SSL v2，SSL v3，TLS v1.0，TLS v1.1和TLS v1.2：  </p><ul><li>SSL v2 是不安全的，不能使用。此协议版本非常糟糕，即使它们位于完全不同的服务器（DROWN 攻击）上也可以用来攻击具有相同名称的RSA 密钥和站点。</li><li>当与 HTTP（POODLE 攻击）一起使用时，SSL v3 是不安全的，当与其他协议一起使用时，SSL v3 是弱的。它也是过时的，不应该被使用。</li><li>TLS v1.0 也是不应该使用的传统协议，但在实践中通常仍然是必需的。其主要弱点（BEAST）在现代浏览器中得到缓解，但其他问题仍然存在。</li><li>TLS v1.1 和 v1.2 都没有已知的安全问题，只有 v1.2 提供了现代的加密算法。</li></ul><hr><p>根据nginx版本不同,<br>*<em>nginx1.15.0更新日志<br>Changes with nginx 1.15.0                                        05 Jun 2018<br>    *) Change: the “ssl” directive is deprecated; the “ssl” parameter of the<br>       “listen” directive should be used instead.  *</em><br>so，nginx1.15.0前ssl开启使用 </p><div class="hljs"><pre><code class="hljs plain">listen443ssl on</code></pre></div><p>1.15.0之后使用</p><div class="hljs"><pre><code class="hljs plain">listen 443 ssl</code></pre></div><p>否则会报<code>the &quot;ssl&quot; directive is deprecated, use the &quot;listen ... ssl&quot; directive instead in /etc/nginx/nginx.conf</code>错误<br>如果是没有使用docker直接使用的nginx到这一步就可以重启nginx然后通过https访问了。</p><h5 id="3-docker映射修改"><a href="#3-docker映射修改" class="headerlink" title="3.docker映射修改"></a>3.docker映射修改</h5><p>由于我是用的是docker的nginx容器，所以需要修改一下映射命令（之前的文章有写）<br>加上新的ssl文件夹和443端口映射（443端口一定要加上，否则还是访问不了）</p><div class="hljs"><pre><code class="hljs plain">docker run --name nginx80 -d -p 443:443 -p 80:80 -v &#x2F;data&#x2F;nginx&#x2F;html:&#x2F;etc&#x2F;nginx&#x2F;html -v &#x2F;data&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf  -v &#x2F;data&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx -v &#x2F;data&#x2F;nginx&#x2F;conf.d:&#x2F;etc&#x2F;nginx&#x2F;conf.d -v &#x2F;data&#x2F;nginx&#x2F;ssl:&#x2F;etc&#x2F;nginx&#x2F;ssl -d nginx:latest</code></pre></div><p>然后就可以愉快的使用https访问自己的网站啦！</p><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><span id="1">[1]<a href="https://blog.myssl.com/ssl-and-tls-deployment-best-practices/" target="_blank" rel="noopener" _blank>HTTPS 安全最佳实践（一）之SSL/TLS部署</a></span>]]></content>
    
    
    <categories>
      
      <category>HTTPS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>Docker</tag>
      
      <tag>HTTPS</tag>
      
      <tag>SSL／TLS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx实现负载均衡的几种方法</title>
    <link href="/2019/09/15/nginx-load-balancing/"/>
    <url>/2019/09/15/nginx-load-balancing/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、Nginx负载均衡的集中方式介绍"><a href="#一、Nginx负载均衡的集中方式介绍" class="headerlink" title="一、Nginx负载均衡的集中方式介绍"></a><strong>一、Nginx负载均衡的集中方式介绍</strong></h3><h4 id="1-1-轮询"><a href="#1-1-轮询" class="headerlink" title="1.1 轮询"></a><strong>1.1 轮询</strong></h4><p>轮询方式是Nginx负载默认的方式，顾名思义，所有请求都按照时间顺序分配到不同的服务上，如果服务Down掉，可以自动剔除，如下配置后轮训1001服务和1002服务。</p><div class="hljs"><pre><code class="hljs plain">upstream  localhost-server &#123;       server    localhost:1001;       server    localhost:1002;&#125;</code></pre></div><h4 id="1-2-权重"><a href="#1-2-权重" class="headerlink" title="1.2 权重"></a><strong>1.2 权重</strong></h4><p>指定每个服务的权重比例，weight和访问比率成正比，通常用于后端服务机器性能不统一，将性能好的分配权重高来发挥服务器最大性能，如下配置后1002服务的访问比率会是1001服务的二倍。</p><div class="hljs"><pre><code class="hljs plain">upstream  localhost-server &#123;       server    localhost:1001 weight&#x3D;1;       server    localhost:1002 weight&#x3D;2;&#125;</code></pre></div><h4 id="1-3-iphash"><a href="#1-3-iphash" class="headerlink" title="1.3 iphash"></a><strong>1.3 iphash</strong></h4><p>每个请求都根据访问ip的hash结果分配，经过这样的处理，每个访客固定访问一个后端服务，如下配置（ip_hash可以和weight配合使用）。</p><div class="hljs"><pre><code class="hljs plain">upstream  localhost-server &#123;       ip_hash;        server    localhost:1001 weight&#x3D;1;       server    localhost:1002 weight&#x3D;2;&#125;</code></pre></div><h4 id="1-4-最少连接"><a href="#1-4-最少连接" class="headerlink" title="1.4 最少连接"></a><strong>1.4 最少连接</strong></h4><p>将请求分配到连接数最少的服务上。</p><div class="hljs"><pre><code class="hljs plain">upstream  localhost-server &#123;       least_conn;       server    localhost:1001 weight&#x3D;1;       server    localhost:1002 weight&#x3D;2;&#125;</code></pre></div><h4 id="1-5-fair"><a href="#1-5-fair" class="headerlink" title="1.5 fair"></a><strong>1.5 fair</strong></h4><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><div class="hljs"><pre><code class="hljs plain">upstream  localhost-server &#123;       server    localhost:1001 weight&#x3D;1;       server    localhost:1002 weight&#x3D;2;       fair;  &#125;</code></pre></div><h3 id="二、Nginx配置"><a href="#二、Nginx配置" class="headerlink" title="二、Nginx配置"></a><strong>二、Nginx配置</strong></h3><p>以轮训为例，nginx.conf完整代码。</p><div class="hljs"><pre><code class="hljs plain">worker_processes  1;events &#123;    worker_connections  1024;&#125;http &#123;   upstream  localhost-server &#123;       server    localhost:1001;       server    localhost:1002;   &#125;   server &#123;       listen       80;       server_name  localhost;       location &#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;localhost-server;        proxy_redirect default;      &#125;    &#125;&#125;</code></pre></div><p>如果要修改负载均衡算法修改对应upstream模块即可。</p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>负载均衡</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装Nginx</title>
    <link href="/2019/09/13/Docker-pull-Nginx/"/>
    <url>/2019/09/13/Docker-pull-Nginx/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="1-查看可用的-Nginx-版本"><a href="#1-查看可用的-Nginx-版本" class="headerlink" title="1.查看可用的 Nginx 版本"></a>1.<strong>查看可用的 Nginx 版本</strong></h4><p>可以用<code>docker search nginx</code> 命令来查看可用版本</p><h4 id="2-取-Nginx-镜像"><a href="#2-取-Nginx-镜像" class="headerlink" title="2.取 Nginx 镜像"></a>2.<strong>取 Nginx 镜像</strong></h4><p>这里我们拉取官方的最新版本的镜像：<code>docker pull nginx:latest</code>  </p><h4 id="3-查看本地镜像"><a href="#3-查看本地镜像" class="headerlink" title="3.查看本地镜像"></a>3.<strong>查看本地镜像</strong></h4><p>使用以下命令来查看是否已安装了 nginx：<code>docker images</code></p><div class="hljs"><pre><code class="hljs plain">docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEnginx               latest              c7460dfcab50        2 months ago        126MBredis               latest              f7302e4ab3a8        7 months ago        98.2MB</code></pre></div><p>可以看到我们已经安装了最新版本（latest）的 nginx 镜像。</p><h4 id="4-运行容器"><a href="#4-运行容器" class="headerlink" title="4.运行容器"></a>4.<strong>运行容器</strong></h4><p>安装完成后，我们可以使用以下命令来运行 nginx 容器：  </p><div class="hljs"><pre><code class="hljs plain">docker run --name nginx-test -p 8080:80 -d nginx</code></pre></div><p>参数说明：</p><p>–name nginx-test：容器名称。<br>-p 8080:80： 端口进行映射，将本地 8080 端口映射到容器内部的 80 端口。<br>-d nginx： 设置容器在在后台一直运行。</p><h4 id="5-安装成功"><a href="#5-安装成功" class="headerlink" title="5.安装成功"></a>5.<strong>安装成功</strong></h4><p>最后我们可以通过浏览器可以直接访问 8080 端口的 nginx 服务。</p><h4 id="6-写在后面"><a href="#6-写在后面" class="headerlink" title="6.写在后面"></a>6.<strong>写在后面</strong></h4><p>执行完前面的步骤就可以在docker里使用nginx,但是我建议直接从容器里复制一份nginx文件到宿主，这样映射起来更加简洁明了</p><h5 id="6-1查看容器"><a href="#6-1查看容器" class="headerlink" title="6.1查看容器"></a>6.1查看容器</h5><p><code>docker ps</code></p><h5 id="6-2进入容器目录"><a href="#6-2进入容器目录" class="headerlink" title="6.2进入容器目录"></a>6.2进入容器目录</h5><p><code>docker exec -it containerID /bin/bash</code></p><h5 id="6-3列出文件列表"><a href="#6-3列出文件列表" class="headerlink" title="6.3列出文件列表"></a>6.3列出文件列表</h5><p><code>ls -l</code><br>结果如下</p><div class="hljs"><pre><code class="hljs plain">root@c7837a1ec864:&#x2F;# ls -ltotal 76drwxr-xr-x  2 root root 4096 Dec 24 00:00 bindrwxr-xr-x  2 root root 4096 Nov 10 12:17 bootdrwxr-xr-x  5 root root  340 Apr 16 09:44 devdrwxr-xr-x  1 root root 4096 Apr 15 08:29 etcdrwxr-xr-x  2 root root 4096 Nov 10 12:17 homedrwxr-xr-x  1 root root 4096 Jan  9 22:20 libdrwxr-xr-x  2 root root 4096 Dec 24 00:00 lib64drwxr-xr-x  2 root root 4096 Dec 24 00:00 mediadrwxr-xr-x  2 root root 4096 Dec 24 00:00 mntdrwxr-xr-x  2 root root 4096 Dec 24 00:00 optdr-xr-xr-x 95 root root    0 Apr 16 09:44 procdrwx------  2 root root 4096 Dec 24 00:00 rootdrwxr-xr-x  1 root root 4096 Apr 16 09:44 rundrwxr-xr-x  2 root root 4096 Dec 24 00:00 sbindrwxr-xr-x  2 root root 4096 Dec 24 00:00 srvdr-xr-xr-x 13 root root    0 Apr 15 05:22 sysdrwxrwxrwt  1 root root 4096 Jan  9 22:20 tmpdrwxr-xr-x  1 root root 4096 Dec 24 00:00 usrdrwxr-xr-x  1 root root 4096 Dec 24 00:00 var</code></pre></div><p>看需要复制文件，我直接将整个nginx文件夹复制到了本地</p><h5 id="6-4复制"><a href="#6-4复制" class="headerlink" title="6.4复制"></a>6.4复制</h5><p><code>docker cp -a containerID:/nginx /data/nginx</code><br> 然后根据需求进行本地映射</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker使用</title>
    <link href="/2019/09/13/Docker/"/>
    <url>/2019/09/13/Docker/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-Docker的简介"><a href="#1-Docker的简介" class="headerlink" title="1.Docker的简介"></a>1.Docker的简介</h3><p>Docker 是一个开源的应用容器引擎，基于Go语言并遵从Apache2.0协议开源。让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。</p><h3 id="2-Docker的组成："><a href="#2-Docker的组成：" class="headerlink" title="2.Docker的组成："></a>2.Docker的组成：</h3><ul><li>1 Docker Client 客户端</li><li>2 Docker Daemon 守护进程</li><li>3 Docker Image 镜像</li><li>4 Docker Container 容器<br>从2017年3月开始Docker在原来的基础上分为两个分支版本: Docker CE 和 Docker EE。Docker CE 即社区免费版，Docker EE 即企业版，强调安全，但需付费使用。</li></ul><h3 id="3Docker-CE的安装"><a href="#3Docker-CE的安装" class="headerlink" title="3Docker CE的安装"></a>3Docker CE的安装</h3><h4 id="1-卸载较旧版本"><a href="#1-卸载较旧版本" class="headerlink" title="1.卸载较旧版本"></a>1.卸载较旧版本</h4><p>较旧版本的Docker被称为docker或docker-engine,如果已安装这些，请卸载它们。未安装略过此步骤</p><div class="hljs"><pre><code class="hljs plain">yum remove -y docker \              docker-client \              docker-client-latest \              docker-common \              docker-latest \              docker-latest-logrotate \              docker-logrotate \              docker-engine</code></pre></div><h4 id="2-安装所需要的软件"><a href="#2-安装所需要的软件" class="headerlink" title="2.安装所需要的软件"></a>2.安装所需要的软件</h4><div class="hljs"><pre><code class="hljs plain">yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre></div><h4 id="3-设置Docker的存储库"><a href="#3-设置Docker的存储库" class="headerlink" title="3.设置Docker的存储库"></a>3.设置Docker的存储库</h4><div class="hljs"><pre><code class="hljs plain">yum-config-manager --add-repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</code></pre></div><h4 id="4-安装最新版Docker-ce"><a href="#4-安装最新版Docker-ce" class="headerlink" title="4.安装最新版Docker-ce"></a>4.安装最新版Docker-ce</h4><div class="hljs"><pre><code class="hljs plain">yum install -y docker-ce</code></pre></div><p><strong>如遇错误提示：</strong><br>错误：软件包：3:docker-ce-18.09.6-3.el7.x86_64 (docker-ce-stable)<br>需要：container-selinux &gt;= 2.9</p><p>执行以下命令,下载container-selinux-2.95的rpm包</p><div class="hljs"><pre><code class="hljs plain">wget http:&#x2F;&#x2F;mirror.centos.org&#x2F;centos&#x2F;7&#x2F;extras&#x2F;x86_64&#x2F;Packages&#x2F;container-selinux-2.95-2.el7_6.noarch.rpm</code></pre></div><p>安装</p><div class="hljs"><pre><code class="hljs plain">rpm -ivh container-selinux-2.95-2.el7_6.noarch.rpm</code></pre></div><p>再次执行安装命令:</p><div class="hljs"><pre><code class="hljs plain">yum install -y docker-ce</code></pre></div><h4 id="5-启动docker"><a href="#5-启动docker" class="headerlink" title="5.启动docker"></a>5.启动docker</h4><div class="hljs"><pre><code class="hljs plain">systemctl daemon-reload &amp;&amp; systemctl start docker</code></pre></div><p>查看docker的版本</p><div class="hljs"><pre><code class="hljs docker">```Client: Version:           <span class="hljs-number">18.09</span>.<span class="hljs-number">6</span> API version:       <span class="hljs-number">1.39</span> Go version:        go1.<span class="hljs-number">10.8</span> Git commit:        <span class="hljs-number">481</span>bc77156 Built:             Sat May  <span class="hljs-number">4</span> <span class="hljs-number">02</span>:<span class="hljs-number">34</span>:<span class="hljs-number">58</span> <span class="hljs-number">2019</span> OS/Arch:           linux/amd64 Experimental:      falseServer: Docker Engine - Community Engine:  Version:          <span class="hljs-number">18.09</span>.<span class="hljs-number">6</span>  API version:      <span class="hljs-number">1.39</span> (minimum version <span class="hljs-number">1.12</span>)  Go version:       go1.<span class="hljs-number">10.8</span>  Git commit:       <span class="hljs-number">481</span>bc77  Built:            Sat May  <span class="hljs-number">4</span> <span class="hljs-number">02</span>:<span class="hljs-number">02</span>:<span class="hljs-number">43</span> <span class="hljs-number">2019</span>  OS/Arch:          linux/amd64  Experimental:     false</code></pre></div><p>即<strong>安装成功</strong><br><strong>查看更详细的的信息</strong><code>docker info</code><br><strong>Docker常用命令</strong><br>可以直接在终端输入<code>docker --help</code>列出所有docker的用法以及所有命令</p><p><strong>查看本地存在的docker镜像</strong><code>docker images</code></p><div class="hljs"><pre><code>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEnginx               latest              c7460dfcab50        2 months ago        126MBredis               latest              f7302e4ab3a8        7 months ago        98.2MB</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令</title>
    <link href="/2019/08/26/Linux-common-commands/"/>
    <url>/2019/08/26/Linux-common-commands/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-cd命令"><a href="#1-cd命令" class="headerlink" title="1.cd命令"></a>1.cd命令</h3><p><code>命令格式：cd &lt;路径&gt;</code><br>意义：cd是change directory 的缩写；cd命令后面跟一个路径，用于切换当前用户所在的路径，其中路径可以是绝对路径也可以是相对路径。<br>示例：<br><code>cd /system/bin</code> 表示切换到/system/bin路径下。<br><code>cd logs</code> 表示切换到logs路径下。<br><code>cd /</code> 表示切换到根目录。<br><code>cd ../</code> 表示切换到上一层路径。</p><h3 id="2-ls命令"><a href="#2-ls命令" class="headerlink" title="2.ls命令"></a>2.ls命令</h3><p><code>命令格式：ls &lt;参数&gt; &lt;路径&gt;</code><br>意义：ls是list的缩写；ls命令后面可以跟一个路径或参数，也可以不跟，表示列出路径或当前目录下的所有文件信息。最常用的的参数是“-l”，也就是“ls -l”命令。<br>示例：<br><code>ls /</code>显示根目录下的所有文件及文件夹。<br><code>ls -l /data</code>显示/data路径下的所有文件及文件夹的详细信息。<br><code>ls -l</code>显示当前路径下的所有文件及文件夹的详细信息<br><code>ls *l wc</code>显示当前目录下面的文件数量。</p><h3 id="3-rm命令"><a href="#3-rm命令" class="headerlink" title="3.rm命令"></a>3.rm命令</h3><p><code>命令格式： rm &lt;文件&gt; 或 rm -r &lt;文件夹&gt;</code><br>意义：rm是remove 的缩写。用于删除文件或文件夹，常用参数-r -f，-r表示删除目录，也可以用于删除文件，-f表示强制删除，不需要确认。同样的，删除文件前需保证当前用户对当前路径有修改的权限。<br>示例：<br><code>rm -rf path</code> 删除path。<br><code>rm test.txt</code> 删除test.txt。</p><h3 id="4-mkdir命令"><a href="#4-mkdir命令" class="headerlink" title="4.mkdir命令"></a>4.mkdir命令</h3><p><code>命令格式： mkdir 文件夹</code><br>意义：mkdir是make directory 的缩写。用于创建文件夹。创建文件夹前需保证当前用户对当前路径有修改的权限。<br>示例：<br><code>mkdir /data/path</code> 在/data路径下创建path文件夹。<br><code>mkdir -p a/b/c</code> 参数 -p用于创建多级文件夹，这句命令表示在当前路径下创建文件夹a， 而a文件夹包含子文件夹b，b文件夹下又包含子文件夹c。</p><h3 id="5-cp命令"><a href="#5-cp命令" class="headerlink" title="5.cp命令"></a>5.cp命令</h3><p><code>命令格式： cp &lt;文件&gt;&lt;目标文件&gt;或者cp -r&lt;文件夹&gt;&lt;目标文件夹&gt;</code><br>意义：cp是copy 的缩写。用于复制文件或文件夹。<br>示例：<br><code>cp /data/logs /data/local/tmp/logs</code>复制/data路径下的logs到/data/local/tmp路径下。<br><code>cp 1.sh /sdcard/</code> 复制当前路径下的1.sh到/sdcard下。</p><h3 id="6-ps命令"><a href="#6-ps命令" class="headerlink" title="6.ps命令"></a>6.ps命令</h3><p><code>ps [options] [--help]</code><br>用于显示当前进程 (process) 的状态。<br>参数：</p><p>ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义<br>-A 列出所有的行程<br>-w 显示加宽可以显示较多的资讯<br>-au 显示较详细的资讯<br>-aux 显示所有包含其他使用者的行程<br>au(x) 输出格式 :<br>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND<br>USER: 行程拥有者<br>PID: pid<br>%CPU: 占用的 CPU 使用率<br>%MEM: 占用的记忆体使用率<br>VSZ: 占用的虚拟记忆体大小<br>RSS: 占用的记忆体大小<br>TTY: 终端的次要装置号码 (minor device number of tty)<br>STAT: 该行程的状态:<br>D: 无法中断的休眠状态 (通常 IO 的进程)<br>R: 正在执行中<br>S: 静止状态<br>T: 暂停执行<br>Z: 不存在但暂时无法消除<br>W: 没有足够的记忆体分页可分配<br>&lt;: 高优先序的行程<br>N: 低优先序的行程<br>L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)<br>START: 行程开始时间<br>TIME: 执行的时间<br>COMMAND:所执行的指令<br>示例：<br><code>ps -A</code> 显示进程信息<br>显示指定用户信息<br><code>ps -u root</code>显示root进程用户信息<br>显示所有进程信息，连同命令行<br><code>ps -ef</code>显示所有命令，连带命令行<br><code>ps -ef |grep java</code> 正在运行的java进程</p><h3 id="7-kill命令"><a href="#7-kill命令" class="headerlink" title="7.kill命令"></a>7.kill命令</h3><p><code>命令格式：kill PID码</code><br>意义：结束当前进程<br>示例：<br>先通过输入命令<code>ps au</code>查看进程，找到需要终止进程的PID再通过kill PID即可，如我这里想要终止的进程是vim test.py，查到的PID是3163，我们可以输入kill 3163结束这个程序，如果结束不了，可以通过kill -9 PID码强制结束，即kii -9 3163</p><h3 id="8-find命令"><a href="#8-find命令" class="headerlink" title="8.find命令"></a>8.find命令</h3><p><code>命令格式：find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \;</code><br>意义：在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。 </p><p>参数说明 :</p><p>find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p><p>expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</p><p>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</p><p>-amin n : 在过去 n 分钟内被读取过</p><p>-anewer file : 比文件 file 更晚被读取过的文件</p><p>-atime n : 在过去n天内被读取过的文件</p><p>-cmin n : 在过去 n 分钟内被修改过</p><p>-cnewer file :比文件 file 更新的文件</p><p>-ctime n : 在过去n天内被修改过的文件</p><p>-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</p><p>-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</p><p>-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写</p><p>-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。</p><p>d: 目录</p><p>c: 字型装置文件</p><p>b: 区块装置文件</p><p>p: 具名贮列</p><p>f: 一般文件</p><p>l: 符号连结</p><p>s: socket</p><p>-pid n : process id 是 n 的文件</p><p>你可以使用 ( ) 将运算式分隔，并使用下列运算。</p><p>exp1 -and exp2</p><p>! expr</p><p>-not expr</p><p>exp1 -or exp2</p><p>exp1, exp2<br>示例：<br><code>find . -name &quot;*.c&quot;</code>将目前目录及其子目录下所有延伸档名是 c 的文件列出来。<br><code># find . -type f</code>将目前目录其其下子目录中所有一般文件列出<br><code>find / -size +500M -print0|xargs -0 du -m|sort -nr</code>find指令为找出500M以上的文件，print0和xargs -0配合使用，用来解决文件名中有空格或特殊字符问题。du -m是查看这些文件的大小，并以m为单位显示。最后sort -nr是按照数字反向排序（大的文件在前）<br><code>find / -name *xxx*.c</code> 模糊查找xxx.c的文件</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown语法</title>
    <link href="/2019/08/08/How_to_use_markdown/"/>
    <url>/2019/08/08/How_to_use_markdown/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h5 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h5><p>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。<br>注：标准语法一般在#后跟个空格再写文字</p><p><strong>示例</strong></p><div class="hljs"><pre><code class="hljs plain"># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题</code></pre></div><p><strong>效果</strong>  </p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><hr><h5 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h5><p>加粗<br>要加粗的文字左右分别用两个*号包起来</p><p>斜体<br>要倾斜的文字左右分别用一个*号包起来</p><p>斜体加粗<br>要倾斜和加粗的文字左右分别用三个*号包起来</p><p>删除线<br>要加删除线的文字左右分别用两个~~号包起来</p><p><strong>示例</strong></p><div class="hljs"><pre><code class="hljs plain">**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~</code></pre></div><p><strong>效果</strong>  </p><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del>  </p><hr><h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br>n个…<br><strong>示例</strong></p><div class="hljs"><pre><code class="hljs plain">&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</code></pre></div><p><strong>效果</strong>  </p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><hr><h5 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h5><p>三个或者三个以上的 - 或者 * 都可以。<br><strong>示例</strong></p><div class="hljs"><pre><code class="hljs plain">-------********</code></pre></div><p><strong>效果</strong>   </p><hr><hr><hr><hr><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><p>语法：</p><p>![图片alt](图片地址 ‘’图片title’’)</p><p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加<br><strong>示例</strong></p><div class="hljs"><pre><code class="hljs plain">![blockchain](https:&#x2F;&#x2F;ss0.bdstatic.com&#x2F;70cFvHSh_Q1YnxGkpoWK1HF6hhy&#x2F;it&#x2F;u&#x3D;702257389,1274025419&amp;fm&#x3D;27&amp;gp&#x3D;0.jpg &quot;区块链&quot;)</code></pre></div><p><strong>效果</strong><br><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&fm=27&gp=0.jpg" srcset="/img/loading.gif" alt="blockchain" title="区块链"></p><hr><h5 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h5><p>语法：</p><p><a href="超链接地址" title="超链接title">超链接名</a><br>title可加可不加<br><strong>示例</strong></p><div class="hljs"><pre><code class="hljs plain">[简书](http:&#x2F;&#x2F;jianshu.com)[百度](http:&#x2F;&#x2F;baidu.com)</code></pre></div><p><strong>效果</strong><br><a href="http://jianshu.com" target="_blank" rel="noopener">简书</a><br><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><hr><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><ul><li>1.无序列表<br>语法：<br>无序列表用 - + * 任何一种都可以</li></ul><p><strong>示例</strong>  </p><div class="hljs"><pre><code class="hljs plain">- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格</code></pre></div><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>2.有序列表<br>语法：<br>数字加点</li></ul><div class="hljs"><pre><code class="hljs plain">1. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格</code></pre></div><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><ul><li>3.列表嵌套<br>上一级和下一级之间敲三个空格即可</li></ul><div class="hljs"><pre><code class="hljs plain">- 一级无序列表内容      - 二级无序列表内容      - 二级无序列表内容      - 二级无序列表内容</code></pre></div><ul><li>一级无序列表内容   <ul><li>二级无序列表内容   </li><li>二级无序列表内容   </li><li>二级无序列表内容</li></ul></li></ul><hr><h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><p>语法：</p><div class="hljs"><pre><code class="hljs plain">表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略</code></pre></div><p><strong>示例</strong></p><div class="hljs"><pre><code class="hljs plain">姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟</code></pre></div><p><strong>效果</strong>  </p><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>语法：<br>单行代码：代码之间分别用一个反引号包起来</p><div class="hljs"><pre><code class="hljs plain">&#96;代码内容&#96;</code></pre></div><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><div class="hljs"><pre><code class="hljs plain">(&#96;&#96;&#96;)代码代码  代码（&#96;&#96;&#96;）</code></pre></div><blockquote><p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。  </p></blockquote><p><strong>示例</strong><br>单行代码<br><code>create database hero;</code></p><p>代码块</p><div class="hljs"><pre><code class="hljs plain">function fun()&#123;     echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun();</code></pre></div><h5 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h5><div class="hljs"><pre><code class="hljs flow">st&#x3D;&gt;start: 开始op&#x3D;&gt;operation: My Operationcond&#x3D;&gt;condition: Yes or No?e&#x3D;&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;</code></pre></div><p>摘自<a href="https://www.jianshu.com/p/191d1e21f7ed/" target="_blank" rel="noopener">https://www.jianshu.com/p/191d1e21f7ed/</a></p>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>@Controller与@RestController的区别</title>
    <link href="/2019/08/05/Difference-between-Controller-and-RestController/"/>
    <url>/2019/08/05/Difference-between-Controller-and-RestController/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>1.使用@RestController注解相当于同时在Controller上使用了@Controller+@ResponsBody注解（或者Controller上使用@Controller注解+方法块上使用@ResponseBody注解）；<br>2.只在Controller上使用@RestController注解只能返回return中的内容无法返回jsp/html页面(配置的视图解析器 InternalResourceViewResolver不起作用)<br>3.若想使Controller返回视图则需使用@Controller注解；同时需要返回数据则需在对应方法上加注@ResponseBody</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>注释</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat部署多项目</title>
    <link href="/2019/07/29/Tomcat-build-projects/"/>
    <url>/2019/07/29/Tomcat-build-projects/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-单个Tomcat"><a href="#1-单个Tomcat" class="headerlink" title="1.单个Tomcat"></a>1.单个Tomcat</h3><p>略。<br> 参考<a href="https://www.cnblogs.com/casefour/p/11843582.html" target="_blank" rel="noopener">一个tomcat同时部署多个项目</a></p><h3 id="2-多个Tomcat"><a href="#2-多个Tomcat" class="headerlink" title="2.多个Tomcat"></a>2.多个Tomcat</h3><p>   以windows为例<br>   安装配置多个tomcat后，不同的tomcat配置不同的端口，打开cmd分别进入各个tomcat的bin文件夹输入命令<br>        <code>service.bat install/remove [service_name]/[user username]</code><br> 进行服务的安装卸载。不同端口服务应起不同的名字，不然会报错。然后在windows的服务里进行设置服务的启停以及开机启动。</p> <p><svg class="big-icon" aria-hidden="true">    <use xlink:href="#icon-Tomcat"></use></svg> <svg class="icon" aria-hidden="true">    <use xlink:href="#icon-Tomcat"></use></svg> <svg class="icon" aria-hidden="true">    <use xlink:href="#icon-Tomcat"></use></svg> <svg class="big-icon" aria-hidden="true">    <use xlink:href="#icon-Tomcat"></use></svg><svg class="icon" aria-hidden="true">    <use xlink:href="#icon-Tomcat"></use></svg> </p>]]></content>
    
    
    <categories>
      
      <category>Tomcat</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis</title>
    <link href="/2019/07/28/MyBatis/"/>
    <url>/2019/07/28/MyBatis/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h5 id="和-的区别。"><a href="#和-的区别。" class="headerlink" title="#{}和${}的区别。"></a>#{}和${}的区别。</h5><p>#{}是预编译处理，${}是字符串替换。<br>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；<br>Mybatis在处理{}替换成变量的值。<br>使用#{}可以有效的防止SQL注入，提高系统安全性。</p><h5 id="如何获取自动生成的-主-键值。"><a href="#如何获取自动生成的-主-键值。" class="headerlink" title="如何获取自动生成的(主)键值。"></a>如何获取自动生成的(主)键值。</h5><p>insert 方法总是返回一个int值 - 这个值代表的是插入的行数。<br>而自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。<br>示例：  </p><div class="hljs"><pre><code class="hljs plain">&lt;insert id&#x3D;&quot;insert&quot; parameterType&#x3D;&quot;Spares&quot;         useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;id&quot;&gt;INSERT INTO spares (spares_id, spares_name, spares_type_id, spares_spec)VALUES (#&#123;id&#125;, #&#123;name&#125;, #&#123;typeId&#125;, #&#123;spec&#125;)&lt;&#x2F;insert&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一篇水贴</title>
    <link href="/2019/07/27/Article-1/"/>
    <url>/2019/07/27/Article-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>从自制后台转到hexo,特此纪念。</p></blockquote><p>更换了新的<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">fluid</a>主题,我觉得也很好看，相对于bufferfly配置可能没特别多，但是相对来说能让我找到重心是啥。</p><h2 id="valine邮件通知"><a href="#valine邮件通知" class="headerlink" title="valine邮件通知"></a>valine邮件通知</h2><p>不经意看到有关valine评论邮件提醒的帖子然后也试着在自己的博客里也添加了此功能，不过不知道是因为人品不行还是leancloud趁我不注意调戏我，今天总算是把评论发邮件弄好了。<br>踩的坑竟然是字段错误。。。原文<a href="http://www.zhaojun.im/hexo-valine-modify/" target="_blank" rel="noopener">Hexo 优化 — 支持邮件通知的评论 Valine 增强版</a>   </p><h3 id="1-云引擎部署评论后台"><a href="#1-云引擎部署评论后台" class="headerlink" title="1.云引擎部署评论后台"></a>1.云引擎部署评论后台</h3><p>按照步骤首先进入<a href="https://leancloud.cn/dashboard/applist.html#/apps" target="_blank" rel="noopener">leancloud</a>相应应用——》云引擎——》设置，修改代码库为<br><code>https://github.com/zhaojun1998/Valine-Admin</code></p><p><img src="/images/pasted-0.png" srcset="/img/loading.gif" alt="upload successful"><br>但是我第一步就出错了，</p><p><img src="/images/pasted-5.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-6.png" srcset="/img/loading.gif" alt="upload successful"><br>项目一直down不下来<br>经<a href="https://royce2003.top/" target="_blank" rel="noopener">Royce</a>弟弟指点fork项目至我的github然后修改</p><p><img src="/images/pasted-3.png" srcset="/img/loading.gif" alt="upload successful">node版本，修改地址重新部署，成功~。</p><h3 id="2-添加新变量"><a href="#2-添加新变量" class="headerlink" title="2.添加新变量"></a>2.添加新变量</h3><p>然后设置——》添加新变量</p><p><img src="/images/pasted-7.png" srcset="/img/loading.gif" alt="upload successful"><br>但是按照原文只填写 </p><table><thead><tr><th>key</th><th align="center">value</th></tr></thead><tbody><tr><td>SITE_NAME</td><td align="center">网站名称</td></tr><tr><td>SITE_URL</td><td align="center">网站地址, 最后不要加 <code>/</code></td></tr><tr><td>SMTP_USER</td><td align="center">SMTP 服务用户名，一般为邮箱地址</td></tr><tr><td>SMTP_PASS</td><td align="center">SMTP 密码，一般为授权码，而不是邮箱的登陆密码</td></tr><tr><td>SMTP_SERVICE</td><td align="center">邮件服务提供商，支持 <code>QQ</code>、<code>163</code>、<code>126</code>、<code>Gmail</code>、<code>Yahoo</code>、……</td></tr><tr><td>SENDER_NAME</td><td align="center">寄件人名称</td></tr></tbody></table><p>leancloud会报错</p><div class="hljs"><pre><code class="hljs plain">Error: Mail command failed: 550 Invalid User    at SMTPConnection._formatError (&#x2F;home&#x2F;leanengine&#x2F;app&#x2F;node_modules&#x2F;nodemailer&#x2F;lib&#x2F;smtp-connection&#x2F;index.js:605:19)    at SMTPConnection._actionMAIL (&#x2F;home&#x2F;leanengine&#x2F;app&#x2F;node_modules&#x2F;nodemailer&#x2F;lib&#x2F;smtp-connection&#x2F;index.js:1370:34)    at SMTPConnection.&lt;anonymous&gt; (&#x2F;home&#x2F;leanengine&#x2F;app&#x2F;node_modules&#x2F;nodemailer&#x2F;lib&#x2F;smtp-connection&#x2F;index.js:857:18)    at SMTPConnection._processResponse (&#x2F;home&#x2F;leanengine&#x2F;app&#x2F;node_modules&#x2F;nodemailer&#x2F;lib&#x2F;smtp-connection&#x2F;index.js:764:20)    at SMTPConnection._onData (&#x2F;home&#x2F;leanengine&#x2F;app&#x2F;node_modules&#x2F;nodemailer&#x2F;lib&#x2F;smtp-connection&#x2F;index.js:570:14)    at TLSSocket.&lt;anonymous&gt; (&#x2F;home&#x2F;leanengine&#x2F;app&#x2F;node_modules&#x2F;nodemailer&#x2F;lib&#x2F;smtp-connection&#x2F;index.js:522:47)    at TLSSocket.emit (events.js:311:20)    at addChunk (_stream_readable.js:294:12)    at readableAddChunk (_stream_readable.js:275:11)    at TLSSocket.Readable.push (_stream_readable.js:209:10)    at TLSWrap.onStreamRead (internal&#x2F;stream_base_commons.js:186:23) &#123;  code: &#39;EENVELOPE&#39;,  response: &#39;550 Invalid User&#39;,  responseCode: 550,  command: &#39;MAIL FROM&#39;&#125;Akismet key 异常!Error: No recipients defined    at SMTPConnection._formatError (&#x2F;home&#x2F;leanengine&#x2F;app&#x2F;node_modules&#x2F;nodemailer&#x2F;lib&#x2F;smtp-connection&#x2F;index.js:605:19)    at SMTPConnection._setEnvelope (&#x2F;home&#x2F;leanengine&#x2F;app&#x2F;node_modules&#x2F;nodemailer&#x2F;lib&#x2F;smtp-connection&#x2F;index.js:817:34)    at SMTPConnection.send (&#x2F;home&#x2F;leanengine&#x2F;app&#x2F;node_modules&#x2F;nodemailer&#x2F;lib&#x2F;smtp-connection&#x2F;index.js:443:14)    at sendMessage (&#x2F;home&#x2F;leanengine&#x2F;app&#x2F;node_modules&#x2F;nodemailer&#x2F;lib&#x2F;smtp-transport&#x2F;index.js:226:28)    at &#x2F;home&#x2F;leanengine&#x2F;app&#x2F;node_modules&#x2F;nodemailer&#x2F;lib&#x2F;smtp-transport&#x2F;index.js:284:25    at SMTPConnection._actionAUTHComplete (&#x2F;home&#x2F;leanengine&#x2F;app&#x2F;node_modules&#x2F;nodemailer&#x2F;lib&#x2F;smtp-connection&#x2F;index.js:1354:9)    at SMTPConnection.&lt;anonymous&gt; (&#x2F;home&#x2F;leanengine&#x2F;app&#x2F;node_modules&#x2F;nodemailer&#x2F;lib&#x2F;smtp-connection&#x2F;index.js:378:26)    at SMTPConnection._processResponse (&#x2F;home&#x2F;leanengine&#x2F;app&#x2F;node_modules&#x2F;nodemailer&#x2F;lib&#x2F;smtp-connection&#x2F;index.js:764:20)    at SMTPConnection._onData (&#x2F;home&#x2F;leanengine&#x2F;app&#x2F;node_modules&#x2F;nodemailer&#x2F;lib&#x2F;smtp-connection&#x2F;index.js:570:14)    at TLSSocket.&lt;anonymous&gt; (&#x2F;home&#x2F;leanengine&#x2F;app&#x2F;node_modules&#x2F;nodemailer&#x2F;lib&#x2F;smtp-connection&#x2F;index.js:522:47)    at TLSSocket.emit (events.js:311:20)    at addChunk (_stream_readable.js:294:12)    at readableAddChunk (_stream_readable.js:275:11)    at TLSSocket.Readable.push (_stream_readable.js:209:10)    at TLSWrap.onStreamRead (internal&#x2F;stream_base_commons.js:186:23) &#123;  code: &#39;EENVELOPE&#39;,  command: &#39;API&#39;&#125;</code></pre></div><p>后来添加了</p><table><thead><tr><th>key</th><th align="center">value</th></tr></thead><tbody><tr><td>SENDER_EMAIL</td><td align="center">发件人邮箱</td></tr><tr><td>BLOGGER_EMAIL</td><td align="center">博客邮箱</td></tr><tr><td>AKISMET_KEY</td><td align="center">垃圾留言过滤系统key值</td></tr></tbody></table><p>其中<code>SENDER_EMAIL</code>应该是必填项。<code>AKISMET_KEY</code>可以通过<a href="https://akismet.com/" target="_blank" rel="noopener">akismet</a>注册得到，懒得弄的话也非必填。然后就可以发送成功了</p><div class="hljs"><pre><code class="hljs plain">AT通知邮件成功发送: 250 Mail OK queued as smtp3,xxxxx</code></pre></div><p>通过在新变量里添加新的参数绑定的<code>ADMIN_URL</code>域名便可以远程管理评论了~</p><p><img src="/images/pasted-9.png" srcset="/img/loading.gif" alt="upload successful"></p><table><thead><tr><th>key</th><th align="center">value</th></tr></thead><tbody><tr><td>ADMIN_URL</td><td align="center">域名</td></tr><tr><td>也可以绑定已经备案过的自己的独立域名（leancloud绑定过云引擎域名后上述web主机域名位置显示的还是默认域名，但实际上绑定后的独立域名已经生效了）访问评论管理网页</td><td align="center"></td></tr></tbody></table><p><img src="/images/pasted-10.png" srcset="/img/loading.gif" alt="upload successful"></p><p><img src="/images/pasted-11.png" srcset="/img/loading.gif" alt="upload successful"></p><blockquote><p><strong>每次修改参数一定要重启容器！！！！！！！！！！</strong></p></blockquote><h3 id="3-定时唤醒"><a href="#3-定时唤醒" class="headerlink" title="3.定时唤醒"></a>3.定时唤醒</h3><p>因为免费版本的leancloud云引擎会每天定时休眠6 个小时所以需要设置定时唤醒<br>添加定时任务，名称随便填，选择self_wake任务，添加cron表达式，我设置的同原作者一样<br>0 <em>/20 7-23 * * ?  为*</em>8 点到 23 点每 20 分钟唤醒一次**可自定义</p><p><img src="/images/pasted-4.png" srcset="/img/loading.gif" alt="upload successful"></p><hr><h2 id="加密文章"><a href="#加密文章" class="headerlink" title="加密文章"></a>加密文章</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a><strong>特性</strong></h3><ul><li><p>一旦你输入了正确的密码, 它将会被存储在本地浏览器的localStorage中。再次访问，不需输入密码。</p></li><li><p>支持按标签加密。</p></li><li><p>所有的核心功能都是由原生的API所提供的。 在 Node.js中, 我们使用 Crypto。在浏览器中, 我们使用 Web Crypto API。</p></li><li><p>PBKDF2, SHA256 被用于分发密钥, AES256-CBC 被用于加解密, 还使用 HMAC 来验证密文的来源, 并确保其未被篡改。</p></li><li><p>广泛地使用 Promise 来进行异步操作, 以此确保线程不被杜塞。</p></li><li><p>过时的浏览器将不能正常显示, 因此, 请升级浏览器。</p></li></ul><h3 id="1-安装hexo-blog-encrypt"><a href="#1-安装hexo-blog-encrypt" class="headerlink" title="1. 安装hexo-blog-encrypt"></a><strong>1. 安装hexo-blog-encrypt</strong></h3><div class="hljs"><pre><code class="hljs npm">### **2. 使用**### **2.1 快速使用**将 “password” 字段添加到文章头信息并设置值：</code></pre></div><p>title: 第一篇水贴<br>author: 六六<br>tags:</p><ul><li>Hexo</li><li>valine<br>categories:</li><li>HEXO<br>date: 2019-07-27 11:11:00<br>password: 123456<div class="hljs"><pre><code class="hljs plain">记得部署之前先clean  ### **2.2 全局通过标签加密**在_config中加入</code></pre></div>encrypt: # hexo-blog-encrypt<br>abstract: 有东西被加密了, 请输入密码查看.<br>message: 您好, 这里需要密码.<br>tags:</li><li>{name: tagName, password: 密码A}</li><li>{name: tagName, password: 密码B}<br>template: <div id="hexo-blog-encrypt" data-wpm="" data-whm=""><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="" /><label></label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest=""></script></div><br>wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.<br>wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.<div class="hljs"><pre><code></code></pre></div></li></ul><p>通过tags对文章加密</p><hr><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p>hexo果然省心了好多，只需简单配置几下便可，美滋滋！<br>搜了一下好看的主题，发现<a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">butterFly</a>不错，花里胡哨，就它了，嘻嘻开始配置~<br>额，发现自己沉醉于各种配置不能自拔。。。<br>最后还是换了主题。。。上传至gitee纪念一下我逝去的butterfly…</p>]]></content>
    
    
    <categories>
      
      <category>HEXO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>valine</tag>
      
      <tag>文章加密</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
